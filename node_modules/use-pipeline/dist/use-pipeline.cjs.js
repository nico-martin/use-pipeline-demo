"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const b=require("react"),P=require("@huggingface/transformers"),I=(e,o,s,n={})=>new Promise((r,c)=>{const p=new Map,a=new Map;let O=0;const u=y=>{const t={};return Object.entries(y??{}).forEach(([i,f])=>{if(typeof f=="function"){const g=`cb_${i}`;p.set(g,f),t[i]={__fn:!0,functionId:g}}else t[i]=f}),t};e.onmessage=y=>{const t=y.data;if((t==null?void 0:t.type)==="invokeCallback"){const{functionId:i,args:f}=t,g=p.get(i);g&&g(...f)}if((t==null?void 0:t.type)==="result")if((t==null?void 0:t.id)==="init")r((i,f)=>new Promise((g,d)=>{const l=O++;a.set(l,{resolve:g,reject:d}),e.postMessage({id:l,type:"pipe",data:i,task:o,model_id:s,options:n?u(n):{},pipeOptions:f})}));else{const i=a.get(t.id);i&&(t.error?i.reject(t.error):i.resolve(t.result),a.delete(t.id))}},a.set("init",{resolve:r,reject:c}),e.postMessage({id:"init",type:"pipe",data:null,task:o,model_id:s,options:n?u(n):{}})}),E={webgpu:async()=>!!await navigator.gpu.requestAdapter()},A=async e=>{if(typeof e=="string")return e;for(const o of e)if(o in E?await E[o]():!0)return o;return e[0]};var _=(e=>(e[e.PRELOAD=0]="PRELOAD",e[e.LOADING=1]="LOADING",e[e.READY=2]="READY",e))(_||{});const S=(e,o,s={},n)=>{const[r,c]=b.useState(0),p=b.useRef(null),a=b.useRef({}),[O,u]=b.useState(0),y=b.useMemo(()=>JSON.stringify(s),[s]),t=b.useMemo(()=>!!n,[n]);return b.useEffect(()=>{p.current=null,c(0)},[e,o,y,t]),{progress:O,pipe:async(f,g={})=>{if(!p.current){c(1);const d={...s};d.progress_callback=l=>{if("progress_callback"in s&&s.progress_callback(l),typeof l=="object"&&"status"in l&&l.status==="progress"){a.current[l.file]={loaded:l.loaded,total:l.total};let M=0,w=0;Object.entries(a.current).forEach(([C,{loaded:j,total:D}])=>{M+=D,w+=j}),u(Math.round(w/M*100))}},d.device&&(d.device=await A(d.device)),p.current=n?await I(n,e,o,d):await P.pipeline(e,o,d),c(2)}return p.current(f,g)},status:r}},R=new Map,h=()=>{const e=o=>{const s={};return Object.entries(o??{}).forEach(([n,r])=>{typeof r=="object"&&r&&"__fn"in r&&r.__fn?s[n]=(...c)=>self.postMessage({type:"invokeCallback",functionId:"functionId"in r?r.functionId:null,args:c}):s[n]=r}),s};return{onmessage:async o=>{const{id:s,data:n,task:r,model_id:c,options:p,pipeOptions:a={}}=o.data,O=JSON.stringify({task:r,model_id:c,options:p});let u=R.get(O);u||(u=await P.pipeline(r,c,e(p)),R.set(O,u)),self.postMessage({id:s,type:"ready"}),console.log("pipeOptions",a);const y=n?await u(n,a):null;self.postMessage({id:s,type:"result",result:y})}}};exports.UsePipelineStatus=_;exports.usePipeline=S;exports.webWorkerPipelineHandler=h;
