import b from "react";
import { pipeline as _ } from "@huggingface/transformers";
const j = (e, r, s, n = {}) => new Promise((o, c) => {
  const p = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
  let O = 0;
  const f = (y) => {
    const t = {};
    return Object.entries(y ?? {}).forEach(([i, u]) => {
      if (typeof u == "function") {
        const g = `cb_${i}`;
        p.set(g, u), t[i] = { __fn: !0, functionId: g };
      } else
        t[i] = u;
    }), t;
  };
  e.onmessage = (y) => {
    const t = y.data;
    if ((t == null ? void 0 : t.type) === "invokeCallback") {
      const { functionId: i, args: u } = t, g = p.get(i);
      g && g(...u);
    }
    if ((t == null ? void 0 : t.type) === "result")
      if ((t == null ? void 0 : t.id) === "init")
        o((i, u) => new Promise((g, d) => {
          const l = O++;
          a.set(l, { resolve: g, reject: d }), e.postMessage({
            id: l,
            type: "pipe",
            data: i,
            task: r,
            model_id: s,
            options: n ? f(n) : {},
            pipeOptions: u
          });
        }));
      else {
        const i = a.get(t.id);
        i && (t.error ? i.reject(t.error) : i.resolve(t.result), a.delete(t.id));
      }
  }, a.set("init", { resolve: o, reject: c }), e.postMessage({
    id: "init",
    type: "pipe",
    data: null,
    task: r,
    model_id: s,
    options: n ? f(n) : {}
  });
}), w = {
  // @ts-ignore
  webgpu: async () => !!await navigator.gpu.requestAdapter()
}, A = async (e) => {
  if (typeof e == "string")
    return e;
  for (const r of e)
    if (r in w ? await w[r]() : !0)
      return r;
  return e[0];
};
var m = /* @__PURE__ */ ((e) => (e[e.PRELOAD = 0] = "PRELOAD", e[e.LOADING = 1] = "LOADING", e[e.READY = 2] = "READY", e))(m || {});
const P = (e, r, s = {}, n) => {
  const [o, c] = b.useState(
    0
    /* PRELOAD */
  ), p = b.useRef(null), a = b.useRef({}), [O, f] = b.useState(0), y = b.useMemo(() => JSON.stringify(s), [s]), t = b.useMemo(() => !!n, [n]);
  return b.useEffect(() => {
    p.current = null, c(
      0
      /* PRELOAD */
    );
  }, [e, r, y, t]), {
    progress: O,
    pipe: async (u, g = {}) => {
      if (!p.current) {
        c(
          1
          /* LOADING */
        );
        const d = { ...s };
        d.progress_callback = (l) => {
          if ("progress_callback" in s && s.progress_callback(l), typeof l == "object" && "status" in l && l.status === "progress") {
            a.current[l.file] = {
              loaded: l.loaded,
              total: l.total
            };
            let M = 0, E = 0;
            Object.entries(a.current).forEach(
              ([h, { loaded: D, total: I }]) => {
                M += I, E += D;
              }
            ), f(Math.round(E / M * 100));
          }
        }, d.device && (d.device = await A(d.device)), p.current = n ? await j(n, e, r, d) : await _(e, r, d), c(
          2
          /* READY */
        );
      }
      return p.current(u, g);
    },
    status: o
  };
}, R = /* @__PURE__ */ new Map(), N = () => {
  const e = (r) => {
    const s = {};
    return Object.entries(r ?? {}).forEach(([n, o]) => {
      typeof o == "object" && o && "__fn" in o && o.__fn ? s[n] = (...c) => self.postMessage({
        type: "invokeCallback",
        functionId: "functionId" in o ? o.functionId : null,
        args: c
      }) : s[n] = o;
    }), s;
  };
  return {
    onmessage: async (r) => {
      const {
        id: s,
        data: n,
        task: o,
        model_id: c,
        options: p,
        pipeOptions: a = {}
      } = r.data, O = JSON.stringify({ task: o, model_id: c, options: p });
      let f = R.get(O);
      f || (f = await _(o, c, e(p)), R.set(O, f)), self.postMessage({ id: s, type: "ready" }), console.log("pipeOptions", a);
      const y = n ? await f(n, a) : null;
      self.postMessage({ id: s, type: "result", result: y });
    }
  };
};
export {
  m as UsePipelineStatus,
  P as usePipeline,
  N as webWorkerPipelineHandler
};
